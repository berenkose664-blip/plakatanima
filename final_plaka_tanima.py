# -*- coding: utf-8 -*-
"""final_plaka_tanima.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aKwxKCYhLfxo4ON4z666Bl_ql0vxVe4S
"""

import kagglehub
import os

# Veri kaynaƒüƒ± i√ße aktarƒ±mƒ± yapƒ±lƒ±yor.
smaildurcan_turkish_license_plate_dataset_path = kagglehub.dataset_download('smaildurcan/turkish-license-plate-dataset')

print('Data source import complete.')
print(f"Veri Seti Yolu: {smaildurcan_turkish_license_plate_dataset_path}")
print(f"Klas√∂r i√ßindeki ilk 5 dosya: {os.listdir(smaildurcan_turkish_license_plate_dataset_path)[:5]}")

!pip install ultralytics

# Salt okunur veriyi, YOLO'nun eƒüitilebileceƒüi yazƒ±labilir bir alana ta≈üƒ±r ve klas√∂r adƒ±nƒ± d√ºzeltir.

import shutil
import os

# Kaynak yol: ƒ∞ndirilen veri setinin ger√ßek yolu
source_path = smaildurcan_turkish_license_plate_dataset_path   # kaynak yolu , KaggleHub'ƒ±n veriyi indirdigi yeri ayarlar.(Verinin nerede oldugunu kesin olarak bilmek icin yapƒ±lmalƒ±dƒ±r)
# Hedef yol: Yazƒ±labilir Colab dizini
destination_path = '/content/plaka_data_writable/'    #yazma izni olan yeni bir klasor tanimlar. (Cunku /kaggle/input  yolu salt okunurdur . YOLO'nun egitim sirasinda veriyi duzenleyebilmesi icin yazƒ±labilir bir alana ihtiyaci vardir.)

# Hedef klas√∂r√º temizle
if os.path.exists(destination_path):
    shutil.rmtree(destination_path)

# Veri setini kopyala
try:
    shutil.copytree(source_path, destination_path)   # vwei setini kaynak yoldan hedef yola kopyalar . (salt okunur sorununu birebir kopyalama ile cozeriz)
    print(f"‚úÖ 1. Kopyalama Ba≈üarƒ±lƒ±: {destination_path}")

    # Etiket klas√∂r√ºn√º yeniden adlandƒ±rma (YOLO'nun 'labels' beklemesi i√ßin)
    old_label_path = os.path.join(destination_path, 'label')
    new_label_path = os.path.join(destination_path, 'labels')  #veri setinden gelen label klasorunun adini labels olarak degistirir. Cunku YOLOv8 bircok nesne tespit cercevesi etiket dosyalari icin labels adinda bir klasor bekler. Bu uyumluluk icin yapilir.

    if os.path.exists(old_label_path):
        os.rename(old_label_path, new_label_path)
        print("‚úÖ 2. Etiket klas√∂r√º adƒ± 'label'dan 'labels' olarak g√ºncellendi.")
    else:
        print("‚ùå Hata: 'label' klas√∂r√º bulunamadƒ±.")

    print(f"\n‚úÖ T√ºm i≈ülemler tamamlandƒ±. Yeni Klas√∂r ƒ∞√ßeriƒüi: {os.listdir(destination_path)}")

except Exception as e:
    print(f"‚ùå Kopyalama hatasƒ±: {e}")

# Commented out IPython magic to ensure Python compatibility.
# # plaka_data.yaml adinda bir ayar dosyasi olusturur. YOLO'ya t√ºm ayarlari tek bir yerden vermek icin gerkelidir.
# %%writefile plaka_data.yaml
# path: /content/plaka_data_writable/     # Modelin veri setini yeni kopyaladigimiz yazilabilir yolda aramasini soyler. Hatali salt okunur yolu (eski) kullanmaktan kacinmak icin.
# 
# # Artƒ±k 'labels' klas√∂r√ºn√º kullanƒ±yoruz
# train: images    # egitim ve dogrulama resimlerinin ,ana klasorun icindeki images alt klasorunde oldugunu belirtir. YOLO, bu klasorun icinde resimlerin kendisini , karsiliginda da labels klasorunde etiketlerini arar.
# val: images
# 
# nc: 1     #egitimde sadace bir sininf oldugunu ve (nc=11) ve bu sinifin adinin license_plate oldugunu tanimlar. Modelin neyi tespit etmesi gerektigini bilmesi icin .
# names: ['license_plate']

# plaka_data.yaml dosyasƒ±nƒ± programatik olarak olu≈üturma
with open('plaka_data.yaml', 'w') as f:
    f.write('path: /content/plaka_data_writable/\n')
    f.write('train: images\n')
    f.write('val: images\n')
    f.write('nc: 1\n')
    f.write("names: ['license_plate']\n")
print("plaka_data.yaml dosyasƒ± olu≈üturuldu.")

!pip install ultralytics
from ultralytics import YOLO  #YOLOv8 modelini saglayan resmi Python kutuphanesi. Bu kutuphane ile YOLO modellerini kolayca yukleyebilir, egitebilir ve test edebilirsin.
import torch  #

# GPU kontrol√º
if torch.cuda.is_available():
    print(f"GPU Durumu: AKTƒ∞F. Kullanƒ±lan: {torch.cuda.get_device_name(0)}")
else:
    print("GPU Durumu: PASƒ∞F. L√ºtfen √áalƒ±≈üma Zamanƒ± ayarlarƒ±nƒ±zƒ± kontrol edin.")

# √ñnceden eƒüitilmi≈ü YOLOv8 modelini y√ºkl√ºyoruz.
model = YOLO('yolov8s.pt')  #milyonlarca resim uzerinde daha once egitilmis , kucuk (s=small) bir YOLOv8 modelini(agirliklarini) yukler.

print("Eƒüitim Ba≈ülƒ±yor...")

# Eƒüitimi ba≈ülatma
results = model.train(
    data='plaka_data.yaml',    # Ayar dosyasƒ± . modelin hangi ayar dosyasini kullanacagini gosterir. veri seti yolu ve sƒ±nƒ±f adlarƒ± gibi tum ayarlarƒ± buradan alir.
    epochs=1,                 # Eƒüitim d√∂ng√ºs√º sayƒ±sƒ± . Hizli sonuc almak ve modelin ogrenip ogrenmedigini ilk etapta kontrol etmek  icin 20 yaptik. normalde 50-100 arasƒ±nda olmasƒ± olabilir.
    imgsz=640,                 # G√∂r√ºnt√º boyutu . Tum resimleri 640*640 boyutuna getirir. Modelin calismasi icin tum resimlerin aynƒ± boyutta olmasi gerekir .
    batch=16,                  # Paket boyutu .   Modelin her adimda 16 resimlik guruplar (batch) halinde ogrenmesini soyler . GPU bellegini verimli kullanmak ve egitimi hƒ±zlandƒ±rmak icin .
    name='turkish_lp_detector_final_v3' # Sonu√ß klas√∂r√º .  Egitim sonuclarinin kaydedilecegi klasor adini belirler. Egitim tamamlandiginda kolayca bulmak icin.
)

print("Eƒüitim Tamamlandƒ±!")

# 3. üö® GOOGLE DRIVE BAƒûLANTISI (KAYBOLAN KISIM)
from google.colab import drive
drive.mount('/content/drive')

# 4. Modeli y√ºkle
model = YOLO('yolov8s.pt')

print("Ortam hazƒ±r! Eƒüitime ba≈ülƒ±yoruz...")

!ls -l /content/runs/detect/

# 1. Eƒüitilmi≈ü Modeli Y√ºkleme
best_model_path = '/content/runs/detect/turkish_lp_detector_final_v3/weights/best.pt'
detector = YOLO(best_model_path)

# 2. Doƒürulama (Validation) Modunu √áalƒ±≈ütƒ±rma
# Bu, modelin doƒürulama veri setindeki t√ºm mAP, Precision, Recall deƒüerlerini hesaplar.
print("\n--- Model Performans Metrikleri Hesaplanƒ±yor ---")
metrics = detector.val(
    data='plaka_data.yaml',  # Eƒüitimde kullandƒ±ƒüƒ±nƒ±z ayar dosyasƒ±nƒ± tekrar kullanƒ±n
    imgsz=640,
    batch=16,
    plots=True  # Sonu√ßlarƒ± g√∂rselle≈ütirmek i√ßin (PR eƒürisi vb.)
)

# Modeli tekrar y√ºklemeye gerek yok, sadece √ßƒ±ktƒ± alma kƒ±smƒ±nƒ± d√ºzeltiyoruz.

# 3. Sonu√ßlarƒ± D√ºzg√ºnce G√∂r√ºnt√ºleme
print("\n--- PERFORMANS METRƒ∞KLERƒ∞ (D√ºzeltilmi≈ü √áƒ±ktƒ±) ---")
# mAP deƒüerleri doƒüruydu:
print(f"‚úÖ mAP50-95 (Ortalama Kesinlik): {metrics.box.map}")
print(f"‚úÖ mAP50: {metrics.box.map50}")

# Precision ve Recall deƒüerlerinin d√ºzeltilmi≈ü hali:
print(f"‚úÖ Precision (Kesinlik): {metrics.box.mp}") # 'precision' yerine 'mp' kullanƒ±ldƒ±
print(f"‚úÖ Recall (Geri √áaƒüƒ±rma): {metrics.box.mr}")       # 'recall' yerine 'mr' kullanƒ±ldƒ±

!pip install easyocr
import cv2
import easyocr
import re
import os
import hashlib
from IPython.display import Image as IPImage, display

# =========================================================
# 1Ô∏è‚É£ RESƒ∞M KLAS√ñR√úN√ú OTOMATƒ∞K TARA
# =========================================================
IMAGE_DIR = "/content/plaka_data_writable/images"

image_files = sorted([
    f for f in os.listdir(IMAGE_DIR)
    if f.lower().endswith((".jpg", ".jpeg", ".png"))
])

if not image_files:
    raise Exception("‚ùå Resim klas√∂r√ºnde hi√ß g√∂r√ºnt√º bulunamadƒ±!")

print("üìÇ Bulunan resimler:")
for i, f in enumerate(image_files):
    print(f"{i}: {f}")

# üî¥ SADECE BURAYI DEƒûƒ∞≈ûTƒ∞R
SELECTED_INDEX = 0 # 0,1,2,...

processed_image_path = os.path.join(IMAGE_DIR, image_files[SELECTED_INDEX])
EXPECTED_PLATE = None  # test i√ßin, istersen None yapabilirsin

print(f"\nDEBUG: '{processed_image_path}' g√∂rselinden doƒürudan OCR okumasƒ± yapƒ±lƒ±yor...")

# =========================================================
# 2Ô∏è‚É£ OCR OKUYUCU
# =========================================================
ocr_reader = easyocr.Reader(['tr', 'en'])

# =========================================================
# 3Ô∏è‚É£ YARDIMCI FONKSƒ∞YONLAR (AYNI)
# =========================================================
def file_md5(path):
    h = hashlib.md5()
    with open(path, 'rb') as f:
        for chunk in iter(lambda: f.read(8192), b''):
            h.update(chunk)
    return h.hexdigest()

def normalize_text(s: str) -> str:
    s = s.upper()
    s = re.sub(r'[^A-Z0-9]', '', s)
    return s

def turkish_plate_filter_best(text: str):
    text = normalize_text(text)
    pattern = r'(0[1-9]|[1-7][0-9]|8[01])[A-Z]{1,3}[0-9]{2,4}'
    matches = list(re.finditer(pattern, text))
    if not matches:
        return text
    return max(matches, key=lambda m: len(m.group(0))).group(0)

def fix_raw_text(raw_text: str, expected: str | None):
    raw_norm = normalize_text(raw_text)

    if expected:
        exp_norm = normalize_text(expected)
        if exp_norm in raw_norm:
            return exp_norm

    return turkish_plate_filter_best(raw_norm)

# =========================================================
# 4Ô∏è‚É£ ANA OCR AKI≈ûI (AYNI)
# =========================================================
try:
    print(f"DEBUG: Dosya boyutu: {os.path.getsize(processed_image_path)} bytes")
    print(f"DEBUG: Dosya md5: {file_md5(processed_image_path)}")

    print("DEBUG: OCR'a verilecek i≈ülenmi≈ü g√∂rsel:")
    display(IPImage(filename=processed_image_path))

    img_bgr = cv2.imread(processed_image_path)
    if img_bgr is None:
        raise Exception("cv2.imread g√∂r√ºnt√ºy√º okuyamadƒ±.")

    gray = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)

    # TR alanƒ±nƒ± soldan kƒ±rp
    h, w = gray.shape[:2]
    crop_x = int(w * 0.13)
    gray_crop = gray[:, crop_x:]

    ocr_result_direct = ocr_reader.readtext(
        gray_crop,
        detail=0,
        allowlist='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    )

    raw_text = "".join(ocr_result_direct).replace(" ", "")
    raw_text_fixed = fix_raw_text(raw_text, EXPECTED_PLATE)
    plaka_metni_direct = turkish_plate_filter_best(raw_text_fixed)

    print(f"‚úÖ Okunan plaka metni: '{plaka_metni_direct}'")
    print(f"OCR Ham √áƒ±ktƒ±sƒ±: '{raw_text_fixed}'")

    if EXPECTED_PLATE:
        print(f"Beklenen Plaka: '{EXPECTED_PLATE}'")
        if plaka_metni_direct == EXPECTED_PLATE:
            print("üéâ Harika! Beklenen plaka doƒüru okundu!")
        else:
            print("‚ùå Okunan plaka beklenenle uyu≈ümuyor.")

except Exception as e:
    print(f"‚ùå Hata olu≈ütu: {e}")