# -*- coding: utf-8 -*-
"""Plaka_Tanıma.ipynb 

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ItN2YemfDzVaTSx6A7PhbgxbyNFtAsjW
"""

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.
import kagglehub  # Kütüphane İçe Aktarma: Bu satır, KaggleHub adlı Python kütüphanesini projeye dahil eder. 
                  # Bu kütüphane, Kaggle platformunda bulunan veri setlerini, modelleri ve diğer kaynakları kodunuz içinden kolayca indirmenizi ve kullanmanızı sağlar.
andrewmvd_car_plate_detection_path = kagglehub.dataset_download('andrewmvd/car-plate-detection')  # Veri Seti 1 İndirme: Bu satır, andrewmvd kullanıcısının paylaştığı 
                                                                                                  # car-plate-detection adlı veri setini KaggleHub üzerinden indirir.                              
# İndirilen veri setinin yerel dosya yolunu (bilgisayarınızdaki konumunu) alır ve bu yolu andrewmvd_car_plate_detection_path adlı değişkene atar.
smaildurcan_turkish_license_plate_dataset_path = kagglehub.dataset_download('smaildurcan/turkish-license-plate-dataset')  # Veri Seti 2 İndirme: Bu satır, smaildurcan kullanıcısının paylaştığı 
                                                                                                                          # turkish-license- plate-dataset adlı veri setini indirir.                                                                                                                      
print('Data source import complete.')  # Doğrulama Mesajı: İndirme işlemleri tamamlandıktan sonra, kullanıcının bu adımın başarıyla bittiğini anlaması için ekrana bu mesajı yazdırır.
!pip install -q ultralytics # Ultralytics Kurulumu: Bu satır, YOLO (You Only Look Once) gibi modern nesne tespit modellerini içeren Ultralytics kütüphanesini kurar. 
                            # !pip komutu, Jupyter/Colab ortamında bir komut satırı programı çalıştırmanızı sağlar. -q bayrağı ise kurulumun sessiz (daha az çıktı göstererek) yapılmasını sağlar. 
                            # Plaka Tespiti (Detection) için temel araçtır.
!pip install -q pytesseract  # Pytesseract Kurulumu: Bu, Python'da Tesseract Optik Karakter Tanıma (OCR) motorunu kullanmanızı sağlayan bir kütüphanedir. 
                             # Tesseract, görüntü içindeki metinleri okumak için çok yaygın kullanılır. Karakter Tanıma (Recognition) için gereklidir.
!pip install -q easyocr  # EasyOCR Kurulumu: Bu, farklı dillerde (Türkçe dahil) metin tanıma konusunda başarılı, kullanımı kolay bir OCR kütüphanesidir. 
                         # pytesseract'a alternatif veya onunla birlikte kullanılarak daha güvenilir tanıma sağlamak için kurulur.

import os   # İşletim Sistemi Modülü: Dosya yolları, dizin oluşturma, silme gibi işletim sistemi etkileşimlerini (I/O) yönetmek için temel Python modülüdür.
import cv2  # OpenCV (cv2) Kütüphanesi: Görüntü işleme, kamera yakalama, video analizi gibi görevler için standart haline gelmiş çok güçlü bir kütüphanedir. 
            # Plakayı tespit ettikten sonra görüntüyü kesmek (kırpmak) ve işlemek için kullanılır.
import matplotlib.pyplot as plt # Görselleştirme Kütüphaneleri: Bu kütüphaneler, görüntüleri ekranda göstermek (plt) ve tespit edilen plaka çevresine dikdörtgen kutu çizmek (patches) için kullanılır.
                                # Bu, modelin başarısını görsel olarak kontrol etmek için önemlidir.
import matplotlib.patches as patches
from glob import glob # Dosya Listeleme: Belirli bir desenle eşleşen tüm dosya yollarını (örneğin, bir klasördeki tüm .jpg dosyaları) bulmak için kullanılır. 
                      # Veri setindeki resim dosyalarını kolayca listelemek için kullanışlıdır.
from xml.dom import minidom # XML Ayrıştırıcı: Plaka tespiti veri setleri genellikle XML formatında etiketleme bilgisi içerir (Bounding Box koordinatları).
                            # Bu kütüphane, bu XML dosyalarını okuyup ayrıştırmak (parse etmek) için kullanılır.
import random  # Rastgelelik: Veri setinden rastgele örnekler seçmek veya veri artırma (augmentation) işlemleri için kullanılır.
import easyocr # EasyOCR İçe Aktarma: Kurulumu yukarıda yapılmış olan bu karakter tanıma kütüphanesi, Python kodunda kullanılmak üzere içe aktarılır.
from ultralytics import YOLO # YOLO İçe Aktarma: Kurulumu yukarıda yapılan Ultralytics kütüphanesinden, nesne tespiti modelinin temel sınıfı olan YOLO içe aktarılır.
import yaml # YAML Ayrıştırıcı: YOLO model eğitimi için gerekli olan yapılandırma dosyaları (veri seti yolları, sınıf adları vb.) genellikle YAML formatında yazılır. 
            # Bu kütüphane bu dosyaları okumak için kullanılır.
import numpy as np # Veri Bilimi Temelleri: numpy (çok boyutlu diziler ve matematiksel işlemler), pandas (tablosal veri işleme, veri çerçeveleri) temel veri bilimi ve makine öğrenimi kütüphaneleridir.
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import torch # PyTorch İçe Aktarma: YOLO gibi modern derin öğrenme modelleri genellikle PyTorch çatısı üzerinde çalışır. Bu satır, PyTorch'u projenize dahil eder.
import pytesseract # Pytesseract İçe Aktarma: Karakter tanıma için kurulan bu kütüphane içe aktarılır.
from PIL import Image # Pillow Kütüphanesi: Python'ın temel görüntü işleme kütüphanelerinden biridir. Görüntüleri açmak, kaydetmek ve basit manipülasyonlar yapmak için kullanılır.

# -*- coding: utf-8 -*-
lut={} # Sözlük (Dictionary) Oluşturma: lut (Look-Up Table / Arama Tablosu) adında boş bir Python sözlüğü (dict) oluşturur. 
       # Bu sözlük, etiket isimlerini (string) modelin anlayacağı sayısal sınıf ID'lerine (integer) dönüştürmek için kullanılır.
lut["accessory"] =0 # Sınıf Tanımları: Nesne tespiti yapılacak sınıflara (bu örnekte giyim/aksesuar sınıfları) karşılık gelen sayısal etiketleri atar.
lut["top"]       =1 # Örneğin, plaka tanıma için bu satırlar büyük ihtimalle lut["license_plate"] = 0 olmalıydı.
lut["bottom"]    =2 # 'bottom' etiketi 2 sınıf ID'si ile eşleştirilir.
lut["bag"]       =3 # 'bag' etiketi 3 sınıf ID'si ile eşleştirilir.
lut["shoes"]     =4 # 'shoes' etiketi 4 sınıf ID'si ile eşleştirilir.
# Görüntü piksel koordinatlarını YOLO formatına (normalize merkez-genişlik-yükseklik) dönüştüren fonksiyon
# (xmin, xmax, ymin, ymax) -> (x_center, y_center, w, h)
def convert_coordinates(size, box): 
    dh = 1.0/size[1] # Normalizasyon faktörü: 1 / Genişlik (W)
    dw = 1.0/size[0] # Normalizasyon faktörü: 1 / Yükseklik (H)
    # Piksel cinsinden merkez koordinatlarını hesapla
    x = (box[0]+box[1])/2.0  # Merkez X: (xmin + xmax) / 2
    y = (box[2]+box[3])/2.0  # Merkez Y: (ymin + ymax) / 2
    # Piksel cinsinden kutu genişliğini ve yüksekliğini hesapla
    w = box[1]-box[0]  # Genişlik: xmax - xmin
    h = box[3]-box[2]  # Yükseklik: ymax - ymin
    # Merkez X ve Genişliği normalize et (0 ile 1 arasına getir)
    x = x*dw  # x_center_norm = x_center_piksel * dw
    w = w*dw  # w_norm = w_piksel * dw
    # Merkez Y ve Yüksekliği normalize et (0 ile 1 arasına getir)
    y = y*dh  # y_center_norm = y_center_piksel * dh
    h = h*dh  # h_norm = h_piksel * dh
    return (x,y,w,h) # Normalize edilmiş (x_center, y_center, w, h) değerlerini döndür.

# XML etiket dosyalarını okuyup YOLO'nun beklediği TXT etiket dosyalarına dönüştüren ana fonksiyon
def convert_xml2yolo( lut,input_path, output_path ): #Fonksiyon Tanımlama: convert_xml2yolo adında bir fonksiyon tanımlanır.
                                                     #Parametreler:
                                                     #lut: Sınıf adlarını sayısal ID'lere dönüştüren sözlük (lut={"license_plate": 0} gibi).
                                                     #input_path: XML etiket dosyalarının bulunduğu dizin yolu.
                                                     #output_path: Dönüştürülen TXT etiket dosyalarının kaydedileceği hedef dizin yolu.
    
  
    if not os.path.exists(output_path): #Çıktı Dizini Kontrolü: Belirtilen output_path dizininin (klasörün) mevcut olup olmadığını kontrol eder.
         os.makedirs(output_path, exist_ok=True) # Eğer yoksa, çıktı dizinini oluştur (exist_ok=True: zaten varsa hata verme)

    # Belirtilen girdi yolundaki tüm .xml dosyalarını döngüye al
    for fname in glob(f"{input_path}/*.xml"):

        xmldoc = minidom.parse(fname) # minidom kullanarak XML dosyasını oku ve ayrıştır
        annot_fname = fname.split("/")[-1][:-4]  # XML dosya adını al (Dizin yollarını ve uzantıyı kaldır)
                                                 
        fname_out = f"{output_path}/{annot_fname}.txt" # Çıktı TXT dosyasının tam yolunu oluştur

        with open(fname_out, "w") as f: # TXT çıktı dosyasını yazma modunda ('w') açar. 'as f:' yapısı iş bitince dosyayı otomatik kapatır.

            itemlist = xmldoc.getElementsByTagName('object') # XML dosyasından etiketlenmiş tüm nesneleri ('object' etiketlerini) listeler.
            size = xmldoc.getElementsByTagName('size')[0] # XML dosyasından görüntünün boyut bilgilerini ('size' etiketini) çeker.
            width = int((size.getElementsByTagName('width')[0]).firstChild.data) # Görüntü genişliğini (width) çeker ve tam sayıya dönüştürür.
            height = int((size.getElementsByTagName('height')[0]).firstChild.data) # Görüntü yüksekliğini (height) çeker ve tam sayıya dönüştürür.

            for item in itemlist: # Bulunan her bir nesne (plaka, vb.) üzerinde döngü başlatılır.
                # get class label
                classid =  (item.getElementsByTagName('name')[0]).firstChild.data #Nesnenin sınıf adını ('name' etiketi) çeker (örn: 'license_plate').
                if classid in lut: # Sınıf adının (classid) lut sözlüğünde olup olmadığını kontrol eder.
                    label_str = str(lut[classid]) # Sınıf adı sözlükte varsa, sayısal ID'yi (0, 1, 2, vb.) alır ve string'e dönüştürür.
                else:  # Sınıf adı sözlükte yoksa (tanımlanmamışsa)
                    label_str = "0"  #print ("warning: label '%s' not in look-up table" % classid)
                    
                # get bbox coordinates
                # 'bndbox' içinden xmin, ymin, xmax, ymax piksel değerlerini çeker ve float'a dönüştürür.
                xmin = ((item.getElementsByTagName('bndbox')[0]).getElementsByTagName('xmin')[0]).firstChild.data
                ymin = ((item.getElementsByTagName('bndbox')[0]).getElementsByTagName('ymin')[0]).firstChild.data
                xmax = ((item.getElementsByTagName('bndbox')[0]).getElementsByTagName('xmax')[0]).firstChild.data
                ymax = ((item.getElementsByTagName('bndbox')[0]).getElementsByTagName('ymax')[0]).firstChild.data
                # Köşe koordinatlarını (xmin, xmax, ymin, ymax) içeren bir tuple oluşturulur.
                b = (float(xmin), float(xmax), float(ymin), float(ymax)) # Köşe koordinatlarını (b) ve görüntü boyutlarını (width, height) kullanarak
                                                                         # 'convert_coordinates' fonksiyonu ile YOLO formatına (normalize merkez-genişlik-yükseklik) dönüştürülür.
                bb = convert_coordinates((width,height), b) # NOT: Bir sonraki mantıksal adım eksik: Elde edilen 'label_str' ve 'bb' (YOLO koordinatları)
                                                            # değişkenleri kullanılarak verinin dosyaya yazılması gerekir (f.write(...) satırı eksik).

                                                            # # f.write(label_str + " " + " ".join([str(a) for a in bb]) + '\n') 
                                                            # # Bu satır olmalıydı: Sınıf ID'si ve 4 adet normalize edilmiş koordinatı dosyaya yazar.
                #print(bb)

                f.write(label_str + " " + " ".join([("%.6f" % a) for a in bb]) + '\n') # Önceki adımda işlenen verinin (class_id ve YOLO koordinatları) TXT dosyasına yazılması.
                                                                                       # Koordinatlar %6f formatında (virgülden sonra 6 basamak hassasiyetle) boşlukla ayrılıp yazılır.
 
        #print ("wrote %s" % fname_out)
    print("Converting is finished!")

convert_xml2yolo( lut, input_path = "/kaggle/input/car-plate-detection/annotations", output_path = "/kaggle/working/annotations")

def create_directories_if_not_exist(directories: list):
    # Assert: Is the parameter a list?
    assert isinstance(directories, list), "The parameter must be a list (array)."

    # Assert: Is every element in the list a string?
    for dir_path in directories:
        assert isinstance(dir_path, str), f"The element '{dir_path}' in the list is not a string."

    # Create directories
    for dir_path in directories:
        if not os.path.exists(dir_path):
            os.mkdir(dir_path)
            print(f"Created: {dir_path}")
        else:
            print(f"Already exists: {dir_path}")

directories = [
    "/kaggle/working/car_plate_dataset",
    "/kaggle/working/car_plate_dataset/images",
    "/kaggle/working/car_plate_dataset/labels",
    "/kaggle/working/car_plate_dataset/images/train",
    "/kaggle/working/car_plate_dataset/images/val",
    "/kaggle/working/car_plate_dataset/labels/train",
    "/kaggle/working/car_plate_dataset/labels/val"
]

create_directories_if_not_exist(directories)

def split_images_and_labels(val_size = 0.1, input_dir = "/kaggle/input/car-plate-detection",
                           output_dir = "/kaggle/working/car_plate_dataset"):

        img_path = os.listdir(f"{input_dir}/images")
        label_path = os.listdir(f"{input_dir}/annotations")
        imgs_length = len(img_path)
        for i,img in enumerate(img_path):
            spname = "train" if i < int(imgs_length*float(1 - val_size)) else "val"

            #print(spname)

            os.system(f"cp {input_dir}/images/{img} {output_dir}/images/{spname}/{img}")
            #print(f"the image {input_dir}/images/{img} image copied to {output_dir}/images/{spname}/{img}")

            os.system(f"cp /kaggle/working/annotations/{img.split('.')[0]}.txt {output_dir}/labels/{spname}/{img.split('.')[0]}.txt")
            #print(f"the label /kaggle/working/annotations/{img.split('.')[0]}.txt image copied to {output_dir}/labels/{spname}/{img.split('.')[0]}.txt")

        print("Splitting is finished!")

split_images_and_labels()

# Data to be written to the YAML file
data = {
    'train': '/kaggle/working/car_plate_dataset/images/train',
    'val': '/kaggle/working/car_plate_dataset/images/val',
    'names': {
        0: "number_plate"
    } # List formatında olmalı!
}

# Writing the data to a YAML file
with open('data.yaml', 'w') as file:
    yaml.dump(data, file, default_flow_style=False)

print("Data has been written to 'data.yaml'")

# File paths
image_dir = "/kaggle/working/car_plate_dataset/images/train"
label_dir = "/kaggle/working/car_plate_dataset/labels/train"

# Supported extensions
image_extensions = ["*.jpg", "*.jpeg", "*.png"]

# Collect all image files
image_paths = []
for ext in image_extensions:
    image_paths.extend(glob(os.path.join(image_dir, ext)))

# Use the first 9 images
image_paths = sorted(image_paths)[:9]

# Draw a 3x3 grid
fig, axes = plt.subplots(3, 3, figsize=(15, 15))
axes = axes.flatten()

for idx, image_path in enumerate(image_paths):
    img = cv2.imread(image_path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    h, w, _ = img.shape

    # Find the corresponding label file (change extension to .txt)
    base_name = os.path.splitext(os.path.basename(image_path))[0]
    label_path = os.path.join(label_dir, base_name + ".txt")

    # Draw with Matplotlib
    ax = axes[idx]
    ax.imshow(img)
    ax.axis("off")

    # Draw boxes if labels exist
    if os.path.exists(label_path):
        with open(label_path, "r") as f:
            lines = f.readlines()

        for line in lines:
            class_id, x_center, y_center, box_width, box_height = map(float, line.strip().split())

            # Convert from YOLO format to pixels
            x1 = int((x_center - box_width / 2) * w)
            y1 = int((y_center - box_height / 2) * h)
            x2 = int((x_center + box_width / 2) * w)
            y2 = int((y_center + box_height / 2) * h)

            # Draw rectangle
            rect = patches.Rectangle((x1, y1), x2 - x1, y2 - y1,
                                     linewidth=2, edgecolor='red', facecolor='none')
            ax.add_patch(rect)

plt.tight_layout()
plt.show()

# Check the number of GPUs
gpu_count = torch.cuda.device_count()
device = list(range(gpu_count)) if gpu_count > 1 else 0

model = YOLO("yolo11n.pt")

results = model.train(
    data="/content/data.yaml",   # Dataset configuration
    epochs=200,                         # 200 epochs
    imgsz=640,                          # Suitable for smaller images
    batch=32,                            # Adjustable based on GPU RAM
    workers=2,                          # Ideal starting value for Tesla T4
    device=device,                      # GPU setting

    # ✅ Default Regularization & Optimization (YOLO uses its own defaults)
    # If you don't define these parameters, defaults will be used.

    # ✅ Default Augmentations
    augment=True,                       # Default YOLO augmentations are automatically enabled

    # ✅ Early Stopping and Validation
    patience=20,                        # Stops early if no improvement for 10 epochs
    val=True                            # Validation is performed at the end of each epoch
)

!pip install pytesseract
import cv2
import random
import pytesseract
import matplotlib.pyplot as plt
from glob import glob
from ultralytics import YOLO

# Tesseract ayarları
custom_config = r'--oem 3 --psm 7 -c tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

# YOLO modelini yükle
model = YOLO('/content/runs/detect/train/weights/best.pt')

# Görüntüleri al
image_paths = glob("/kaggle/input/turkish-license-plate-dataset/images/*.png") + \
              glob("/kaggle/input/turkish-license-plate-dataset/images/*.jpg")

num_images = min(10, len(image_paths))
random_images = random.sample(image_paths, num_images)

# Boşluksuz Türk plaka formatlayıcı
def format_turkish_plate(text):
    return text.strip().upper().replace(" ", "").replace("-", "")

# Görüntüler üzerinde işlem yap
for img_path in random_images:
    img = cv2.imread(img_path)
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    results = model(img_path, conf=0.4, iou=0.4)
    detected_text_list = []

    for result in results:
        boxes = result.boxes
        for box in boxes:
            x1, y1, x2, y2 = box.xyxy[0].int().tolist()

            # Plaka bölgesini al ve ön işleme uygula
            plate_img = img[y1:y2, x1:x2]
            gray = cv2.cvtColor(plate_img, cv2.COLOR_BGR2GRAY)

            # Sol taraf (mavi TR kısmı) kesiliyor
            h, w = gray.shape
            cut_x = int(w * 0.10)  # %20'sini kes
            gray = gray[:, cut_x:]

            # Orta düzey Gaussian Blur
            blurred = cv2.GaussianBlur(gray, (5, 5), 1)

            # Threshold ile netleştirme
            _, thresh = cv2.threshold(blurred, 150, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

            # OCR işlemi
            text = pytesseract.image_to_string(thresh, config=custom_config)
            formatted_text = format_turkish_plate(text)

            # Eğer plaka uzunluğu yeterliyse kutu çiz ve yazıyı ekle
            if len(formatted_text) >= 6:
                cv2.rectangle(img_rgb, (x1, y1), (x2, y2), (255, 0, 0), 3)
                cv2.putText(img_rgb, formatted_text, (x1, y1 - 10),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2, cv2.LINE_AA)
                detected_text_list.append(formatted_text)

    # Görüntüyü göster
    plt.figure(figsize=(8, 6))
    plt.imshow(img_rgb)
    plt.axis("off")
    plt.show()

    # Tanınan plakaları yazdır
    for i, text in enumerate(detected_text_list):
        print(f"Plate {i + 1}: {text}")
